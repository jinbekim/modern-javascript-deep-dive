# 원시 값과 객체의 비교

## 원시 타입(primitive type) vs 객체 타입(object/reference type)

- 값 변경 가능 여부?
  - 원시 값: 변경 불가(immutable)
  - 객체: 변경 가능(mutable)
- 변수 할당 시 저장되는 값?
  - 원시 값을 변수에 할당하면 변수에는 실제 값이 저장된다.
  - 객체를 변수에 할당하면 변수에는 참조 값이 저장된다.
- 다른 변수에 할당?
  - 원시 값을 갖는 변수를 다른 변수에 할당하면 **원본의 원시 값이 복사**되어 전달(**값에 의한 전달; pass by value**)된다.
  - 객체를 다른 변수에 할당하면 **원본의 참조 값이 복사**되어 전달(**참조에 의한 전달; pass by reference**)된다.

## 원시 값

### 변경 불가능한 값

- 원시 값 자체는 변경할 수 없지만(read-only) 변수 값은 변경(재할당)할 수 있다.
- 데이터의 신뢰성을 보장한다.

  > 상수? 변수의 재할당이 금지된 변수

  ```javascript
  const o = {};

  o.a = 1;
  console.log(o); // {a: 1}
  ```

- 불변성을 갖는 원시 값을 할당한 변수는 재할당으로만 변수 값을 변경할 수 있다.

### 문자열과 불변성

- 유사 배열 객체(array-like object)

  - 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있다.
  - length 프로퍼티를 갖는 객체를 의미한다.

    ```javascript
    var str = "string";

    console.log(str[0]); // 's'

    // 문자열은 원시 값이므로 변경할 수 없다.
    str[0] = "S";
    console.log(str); // 'string'
    ```

### 값에 의한 전달

- 본 변수 값과 복사된 변수의 값은 **다른 메모리에 저장**된 별개의 값이다. → 서로 간섭할 수 없다.
- 변수와 같은 식별자는 메모리 주소를 기억하고 있기 때문에 값이 아닌 **메모리 주소가 전달**된다.

## 객체

> **자바스크립트 객체의 관리 방식**
>
> - 프로퍼티 키를 인덱스로 사용하는 해시 테이블(hash table)과 유사하지만 더 나은 방법으로 객체를 구현한다.
>
> - 클래스 기반 객체지향 프로그래밍 언어(C++)와는 다르게 클래스없이 객체를 생성할 수 있다.
>
> - 객체 생성 후, 동적으로 프로퍼티와 메서드를 추가할 수 있는데 비용, 성능 면에서 비효율적이다.
>
> - 자바스크립트 엔진이 프로퍼티에 접근하기 위해 **히든 클래스(hidden class)** 방식을 사용해 성능을 보장한다.

### 변경 가능한 값

- 객체를 생성, 관리하는 방식은 성능 저하의 원인이 되므로 변경 가능한 값으로 설계되어 있다.
- 여러 개의 식별자가 하나의 객체를 공유할 수 있다.
  > 얕은 복사(shadow copy) vs 깊은 복사(deep copy)
  >
  > - 얕은 복사: 한 단계까지만 복사하며 객체를 할당한 변수를 다른 변수에 할당한다.
  >
  > - 깊은 복사: 객체에 중첩되어 있는 개체까지 모두 복사하며 원시 값을 할당한 변수를 다른 변수에 할당한다.
  >
  > - 둘 다 원본과는 다른 객체다.

### 참조에 의한 전달

- 두 개의 식별자가 하나의 객체를 공유한다.
- **메모리 공간에 저장되어 있는 값을 복사해서 전달한다**: '값에 의한 전달'과는 동일하지만 변수에 저장되어 있는 값(값 혹은 참조)에 따라 다르다.
- 자바스크립트에는 '값에 의한 전달'만이 존재하는데 이를 **'공유에 의한 전달'**이라고 표현한다.

  > 포인터(pointer)가 존재하지 않기 때문에 포인터가 존재하는 다른 프로그래밍 언어의 '참조에 의한 전달'과 의미가 다를 수 있다.
