# 06\_데이터 타입

## 데이터 타입

- 원시 타입과 객체 타입의 두 종류로 나눠진다
- 원시 타입은 7종류의 하위 타입으로 이루어져 있으며, 각각 사용처와 메모리 크기, 해석 방법이 다르다
- 따라서 어디에서 사용하는 값인지에 따라 타입을 명확히 정하는 것이 중요

## 원시 타입

### 숫자 타입 (`number`)

```tsx
var integer = 123;
var double = 123.123;
```

- 다른 언어에서의 `int`, `double`, `float`, `long` 등이 합쳐져 있는 형태라고 생각하면 된다
  - 모든 수를 실수로 처리한다
  - 정수 전용 타입 (`int`) 이나 소수 전용 타입 (`float`) 등이 따로 존재하지 않는다는 뜻
- ECMAScript에 의하면, 배정밀도 64비트 부동소수점 형식을 따른다고 한다
  - 배정밀도 (double precision) 란 쉽게 말해 double 형을 의미하며, 단정밀도 (single precision) 과는 용량과 가수 부분 크기 등이 다르다
  - 배율이 높을 수록 (4배정밀도, 8배정밀도 등) 가수 부분 크기와 용량이 커진다
  - 숫자의 유형이 어떤 것이든간에 64비트 메모리에 2진수로 저장된다

```tsx
var binary = 0b10111101; // 2진수
var octal = 0o275; // 8진수
var decimal = 189;
var hexadecimal = 0xbd; // 16진수
```

- 위의 네 개의 수는 전부 동일하다 (189)
  - 2진수, 8진수, 16진수로 할당은 가능하지만, 별도의 타입은 존재하지 않기 때문에 값을 참조할 경우 (사용할 경우) 10진수로 해석된다

```tsx
console.log(1 === 1.0); // true
console.log(1 / 2); // 0.5
```

- 자바스크립트에서는 모든 수를 실수로 처리하기 때문에, 겉보기엔 정수처럼 보여도 내부적으로는 실수이다
  - 따라서 정수끼리 나눗셈을 수행하는 것 같아도 내부적으론 실수끼리 나눗셈과 똑같기 때문에 실수 값이 반환될 수 있다
  - C와 같이 정수와 소수 타입이 별도로 존재하는 경우 정수끼리의 나눗셈은 예기치 않은 수 버림을 야기하지만, 자바스크립트에서는 소수점으로 표현하므로 `Math.floor` 등으로 후가공이 필요하다

```tsx
console.log(1 / 0); // infinity
console.log(-1 / 0); // -infinity
console.log(1 / "hello"); // NaN
```

- 자바스크립트에서의 number 타입에는 infinity와 NaN도 존재한다
  - `infinity`는 말 그대로 무한대를 의미하며, 양의 무한대와 음의 무한대가 존재한다
  - `NaN`은 Not a Number로, 숫자가 아니라는 의미이다 (산술 연산 결과값 도출이 불가함)
  - `NaN`과 `nan`, `Nan`, `naN` 등은 전부 다른 값임에 주의하자 (자바스크립트는 대소문자를 구분하며, 후자는 식별자로 인식한다)

### 문자열 타입 (`string`)

```tsx
var str = "chichoon zzang";
```

- 텍스트 데이터를 표현할 때 사용된다
  - 0개 이상의 16비트 유니코드 문자의 집합으로, 한국어, 일본어, 한자, 아랍어, 이모지😊 등 대부분의 문자를 표현할 수 있다
- 문자열 변수에 값을 할당할 땐 따옴표 (`””`, `‘’`) 또는 백틱 (````) 을 사용한다
  - 자바스크립트에서는 일반적으로 작은따옴표를 사용하나, 프로젝트별로 합의를 하면 된다
  - 작은따옴표 안에서는 큰따옴표를 사용가능하고, 큰따옴표 안에서는 작은따옴표를 사용가능하다
  - 백틱은 템플릿 리터럴이라는 별도의 체계로 동작한다
- 문자열은 변경 불가능 (`immutable`) 하다

```tsx
var str1 = "chichoon";
var str2 = "zzang";

console.log(str1 + " " + str2); // chichoon zzang
```

- 문자열은 `+` 연산이 가능하며, 좌우로 문자열을 붙여주는 역할을 한다

```tsx
var str = `this is template literal`;

var multiline = `this is
...multiline`; // 멀티라인 문자열

var escapeSequence = `this is\nescape sequence[\t<-tab]`;
```

- 템플릿 리터럴이란 문자열을 백틱 (````)으로 감싼 표기법이다
  - 다양한 서식을 지원하며, 이들은 모두 런타임 시에 일반 문자열 형태로 변환되어 처리된다
- 템플릿 리터럴에서 사용할 수 있는 이스케이프 시퀀스
  - `\0`: 널 문자
  - `\b`: 백스페이스
  - `\f`: 폼 피드 (출력에 영향 없음, 프린트 시에 다음 페이지의 첫 번째 라인으로 이동)
  - `\n`: 개행 (라인 피드)
  - `\r`: 개행 (캐리지 리턴)
  - `\t`: 수평 탭
  - `\v`: 수직 탭
  - `\uXXXX`: 유니코드
  - `\’`, `\”`, `\\`, `\``: 작은따옴표, 큰따옴표, 백슬래시 및 백틱 등 출력에 영향을 주는 특수문자들을 출력하고 싶을 때 사용한다

```tsx
var str1 = "chichoon";
var str2 = "zzang";

console.log("🔥" + str1 + " " + str2 + "🔥"); // 🔥chichoon zzang🔥
console.log(`🔥${str1} ${str2}🔥`); // 🔥chichoon zzang🔥
console.log(`1 + 1 is ${1 + 1}`); // 1 + 1 is 2
console.log("this is not template literal: ${1 + 1}"); // this is not template literal: ${1 + 1}
```

- 앞서 문자열끼리 + 연산을 통해 문자열을 연결할 수 있다고 적었었는데, 표현식 삽입 (Expression Interpolation) 을 사용하면 더 간단하게 문자열을 조합할 수 있다
- 표현식 삽입법은 템플릿 리터럴에서만 가능하며, 표현식을 `${}` 으로 감싼다
  - 위의 예시에서는 변수명을 감쌌는데, 계산식이나 함수 호출 (반환값 사용) 같은 것도 가능하다
  - 템플릿 리터럴이 아닌 문자열에서 `${}`을 사용해봤자 일반 문자열 취급된다

### 불리언 타입 (`boolean`)

```tsx
var foo = true;
var bar = false;

var dap = 1 === 1.0; // true
```

- 참과 거짓을 의미하는 타입이다
- 조건문 (`if`절, 삼항 연산자 등) 에서 분기를 위해 사용된다

### undefined (`undefined`)

```tsx
var notInitialized;

console.log(notInitialized); // undefined
```

- `var` 또는 `let`으로 선언한 변수는 암묵적으로 `undefined`로 초기화된다
  - 기존에 메모리 공간을 차지하던 쓰레기값이 사용되지 않도록, 자바스크립트 엔진에서 자체적으로 초기화하는 값이다
  - 따라서 어떠한 변수의 값이 `undefined`라면, 이 변수는 한 번도 초기화되지 않았음을 알 수 있다
- 물론 개발자가 변수를 직접 `undefined`로 초기화할 수 있으나, 원래의 용도 (초기화 여부 파악) 와는 거리가 멀어지므로 매우 권장하지 않는다
  - “값이 없음” 을 나타내고 싶은 경우, 하단에 서술할 `null`을 사용하자

### null (`null`)

```tsx
var noValueInside = 123;
noValueInside = null; // 123이라는 값과의 연결고리가 사라짐
// 123이 들은 메모리는 연결고리를 가진 변수가 없기 때문에 어떠한 시점에 가비지 콜렉션에 의해 정리될 것이다
```

- `undefined`와 다르게, 값이 없다는 것을 정확히 명시 (의도적 부재: `intentional absence`) 하는 타입이다
  - `null`과 `undefined`는 거의 비슷해보이긴 하지만, `undefined`는 “정의되지 않음” 을 표현하고, `null`은 “값이 없음” 을 표현한다는 점에서 의미가 조금 다르다
  - 변수의 값을 `null`로 덮어씌운다는 것은 곧 "이전에 사용하던 값이 들어있는 메모리 = 이전에 할당한 메모리” 와 현재 식별자의 관계를 끊어버리겠다는 것을 의미한다
- 함수나 메서드를 사용할 때, 유효한 값을 반환할 수 없는 경우 (예외 상황, 오류, 비동기 작업 수행중) 에러 대신 `null`을 반환해서 예외 처리를 돕기도 한다
  - 다만 이 부분에선 `undefined` 파와 `null` 파가 첨예하게 대립하고 있다고 한다
  - 취향껏 통일해서 쓰자..

### 심볼 타입 (Symbol)

```tsx
var symbolKey = Symbol("symbolKey");
```

- ES6 표준에서 추가된 7번째 타입으로, 원시 타입의 값이다
- 다른 값과 절대로 중복되지 않는 유일무이한 값이라는 특성이 있다
  - 이 ‘충돌될리 없다’ 라는 특징 덕에 주로 객체의 유일한 프로퍼티 키를 만들 때 사용된다
- 다른 값은 숫자, 문자 등을 변수에 대입하면 자동으로 타입이 설정되지만 (리터럴), 심볼 타입은 `Symbol` 함수를 호출하여 생성한다 (생성자와 비슷)
  - 이 심볼 값은 절대로 외부에서 확인할 수 없고, 유일무이한 값이다

```tsx
var key = Symbol("key");
var obj = {};
obj[key] = "value";
console.log(obj[key]); // 객체의 Key로 사용
```

- 위처럼 객체의 키로 주로 사용한다

### 객체 타입

- 자바스크립트는 객체 기반의 언어이며, 함수, 배열, 객체, 클래스 등이 전부 사실은 객체로 구성되어 있다
  - 원시 타입이 아닌 모든 값은 객체이다

## 데이터 타입의 필요성

### 데이터 타입에 의한 메모리 공간의 확보와 참조

- 메모리에 값을 저장하기 위해서는 몇 바이트의 메모리 공간을 사용해야 하는지 알아야 낭비와 손실을 최소화할 수 있다
- 또한 한 번에 얼마만큼의 메모리를 읽어들여야 하는지 알아야 데이터의 손실이 없다
  - 숫자 변수가 8바이트를 차지하는데 4바이트만 읽어버리면 원하는 값을 읽지 못하고 값이 망가질 것이다
  - boolean 변수가 4바이트를 차지하는데 16바이트를 읽어버리면 나머지 메모리에서는 쓰레기값을 읽어들여 오류가 날 수 있다

### 데이터 타입에 의한 값의 해석

- 메모리에서 값은 비트의 나열로 저장되며, 이 비트 묶음을 어떻게 해석하느냐에 따라 결과가 달라진다
  - `0100 0001`을 숫자로 해석하면 65지만, 문자로 해석하면 A이다
  - 따라서 변수에 어떤 타입의 값이 할당되었는지 알면 이러한 의문을 해소할 수 있는 것이다

## 동적 타이핑

### 동적 타입 언어

```tsx
let i = 1;
i = "hello?"; // 타입이 문자열로 변경됨
i = true; // 타입이 boolean으로 변경됨
```

- Javascript, Python, PHP, Ruby, Lisp, Perl 등
- 변수를 선언할 때 별도의 타입을 지정하지 않고, 따라서 어떠한 형식의 값이든 변수에 할당될 수 있다
  - 기본적으로 변수는 타입을 갖지 않는다
  - `typeof` 키워드 등으로 변수의 타입을 확인할 수는 있는데, 변수의 타입이라기보단 변수 안에 들어있는 값 (변수에 할당된 값) 의 타입이라고 보는 것이 정확하다
  - 결론은 변수 선언이 아닌 할당 시에 타입이 결정된다는 것이다 ⇒ 이러한 특성을 **동적 타이핑**이라고 한다
- 하나의 변수에 어떠한 타입의 값이든 자유롭게 할당 및 재할당이 가능하며, 타입을 신경쓸 필요가 없으므로 코드 작성 시점에서는 편하다
- 다만 변수의 타입이 언제든지 변경될 수 있다는 위험 때문에 규모가 큰 프로그램에서는 변수의 값을 추적하기가 까다로워진다
  - 자바스크립트 엔진 등의 언어 차원에서 타입이 암묵적으로 변환되는 경우도 있다
  - 변수의 신뢰도가 낮기 때문에, 안정성이 떨어진다
- 이러한 단점 때문에
  - 왠만하면 변수를 사용하지 않고, 상수 등으로 해결한다 (변수의 남발을 최소화한다)
  - 변수의 유효 범위 (= 스코프) 를 최대한 좁게 만들어 부작용을 막는다
  - 전역 변수는 최대한 지양한다 (어디서든지 참조 가능한, 또는 스코프가 넓은 변수는 어디에서 수정될 지 모른다는 위험이 있어 오류의 원인을 찾아내기가 훨씬 까다롭다)
  - 변수의 이름은 변수의 목적이나 의미를 파악할 수 있도록 명확하게 짓는다 ⇒ 길어도 이해가 쉬운 이름을 짓는 것이 훨씬 좋다
- 가독성이 좋은 코드를 작성할 수 있도록 유의하자

### 정적 타입 언어

```c
int a = 12;
char b = 'b';
```

- C, C++, Java, Kotlin, Go, Haskell, Rust, Scala 등
- 변수를 선언할 때 타입을 함께 선언해 주어야 한다
  - 이와 같은 선언법을 명시적 타입 선언 (Explicit type declaration) 이라고 한다
- 정적 타입 언어는 변수의 타입을 변경할 수 없으며, 선언한 타입에 맞는 값만 할당할 수 있다
  - 컴파일 시점에 타입 체크를 수행하며, 타입이 부정확할 경우 컴파일에 실패하고 오류를 반환한다
  - 타입 오류가 있을 경우 컴파일이 아예 안 된다는 특성 덕에 런타임에 에러가 발생할 여지가 줄어들고, 안정적이다
  - 또한 변수의 타입이 변경될 수 없으므로 일관적이고, 따라서 코드를 읽기 수월하다

## 번외

### 라인 피드와 캐리지 리턴

```tsx
            이것은 테스트용 문자열 입니다. 자바스크립트 너무 재밌다 하하하하하| <- 커서 위치
            사실은 어디 잠깐이라도 놀러 갔다 오고 싶은데 너무 바쁘고 정신이 없다

// Line feed (\n)
            이것은 테스트용 문자열 입니다. 자바스크립트 너무 재밌다 하하하하하
            사실은 어디 잠깐이라도 놀러 갔다 오고 싶은데 너무 바쁘고 정신이 없다| <- 커서 위치

// Carriage Return (\r)
커서 위치 -> |이것은 테스트용 문자열 입니다. 자바스크립트 너무 재밌다 하하하하하
            사실은 어디 잠깐이라도 놀러 갔다 오고 싶은데 너무 바쁘고 정신이 없다

// Line feed + Carriage Return (\r\n)
            이것은 테스트용 문자열 입니다. 자바스크립트 너무 재밌다 하하하하하
커서 위치 -> |사실은 어디 잠깐이라도 놀러 갔다 오고 싶은데 너무 바쁘고 정신이 없다
```

- 라인 피드 (Line Feed: `LF`) 와 캐리지 리턴 (Carriage Return: `CR`) 은 타자기에서 유래한 커서 제어 방식이다
  - 라인 피드는 커서의 위치는 고정시키되 종이를 한 줄 올린다 ⇒ 커서가 아랫줄로 그대로 이동한다
  - 캐리지 리턴은 종이를 고정시키되 커서를 맨 앞으로 이동시킨다
  - 따라서 라인 피드와 캐리지 리턴을 동시에 적용하면 커서가 **다음 줄 시작점**으로 이동한다
- 자바스크립트에서 라인 피드와 캐리지 리턴은 모두 개행 (다음 줄 맨 앞으로 이동) 으로 동작하나, 대부분의 경우 라인 피드 `(\n`) 만 사용한다
- 운영체제별로 라인 피드 / 캐리지 리턴 사용 방식에 차이가 있어, 윈도우 환경과 맥OS 환경이 협업을 하다 보면 라인의 맨 끝에서 충돌이 번번히 발생하는 것을 볼 수 있다

### 선언과 정의

- C에서
  - 선언: 컴파일러에게 식별자의 존재만을 알리는 것
  - 정의: 실제로 메모리 주소와 식별자를 연결하고, 변수를 생성하는 것
- 자바스크립트에서
  - 말이 선언이지, 사실은 `undefined` 라는 값으로 동시에 정의하고 있기 때문에 선언 단계에서 메모리 영역 할당, 연결 및 초기화가 모두 이루어진다
  - 따라서 C와 달리, 선언과 정의의 구분이 모호하다
  - ECMAScript에서는 **변수를 선언**하고, **함수를 정의**한다고 표현한다
