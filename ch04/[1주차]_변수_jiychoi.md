# 04\_변수

## 변수란 무엇인가

- 어떠한 값을 메모리상의 어떤 공간에 저장한 것
  - 연산 결과 또는 특정한 값을 다른 연산에 사용하려면 어딘가에 저장이 되어 있어야 한다
  - 다만 아무 곳에나 저장하면 안 되고, 컴퓨터 환경 또는 현재 메모리 상황에 따라 저장 가능한 어떠한 공간을 언어가 확보해 둔다
  - 이 메모리에 저장된 값은 변할 수 있다
- 또한 저장한 값을 사용하려면 이름을 붙여야 함
  - 연산에 사용하기 위한 특정한 값을 메모리 상 어딘가에 저장하고, 그 공간에 이름을 붙인 것을 변수라고 한다

```tsx
var a; // 선언
a = 1; // 할당

var b = 2; // 선언 + 할당 = 초기화
console.log(b); // 참조
```

- 변수에 값을 저장하는 것은 할당
  - 선언과 동시에 값을 할당해주는 것은 초기화
- 변수에 저장된 값을 읽어 사용하는 것은 참조

## 식별자

- 변수의 이름
- 메모리 공간의 주소를 부르는 다른 이름
- 선언을 통해 메모리 공간과 변수 이름을 대응시킨다

## 변수 선언

- 메모리 공간을 확보하고, 이 공간의 주소와 특정 이름을 대응시키는 것
- 자바스크립트에서는 `var` (요즘은 잘 안 씀), `let`, `const` 키워드를 사용한다
  - `var`은 블록 레벨 스코프를 지원하지 않고, 함수 레벨 스코프를 지원하므로 의도치 않은 전역 변수 선언으로 문제를 일으킬 수 있다
  - `var`의 단점을 보완하기 위해 `let`, `const`가 등장한 이후 `var`는 잘 사용하지 않는다
  - `let`, `const`가 등장한 ES6이 `var`이 쓰였던 ES5의 상위 집합이므로 `var`를 가지고 있으며, 몇몇 브라우저 호환성을 위해 ES5 트랜스파일링 시에 `var`로 변환되기도 한다

```tsx
var a; // 선언
```

- 위처럼 선언은 프로그래밍 언어에 의해 특정 메모리 공간을 확보하고, 그 공간을 효과적으로 사용하기 위해 이름 (위 예시에서는 `a`) 을 붙이는 행위이다
- 이렇게 붙인 변수 이름은 실행 컨텍스트에 등록된다
  - 실행 컨텍스트는 자바스크립트 엔진에 의해 소스코드가 평가되고, 실행하기 위한 공간을 제공하며, 실행 결과를 관리하는 영역이다
  - 또한 실행 컨텍스트는 식별자와 스코프를 관리한다
  - 변수 이름과 값은 실행 컨텍스트에 키-값 쌍의 객체로 관리된다

### undefined

```tsx
var b; // 선언만 하고 초기화 X
console.log(b); // undefined
```

- 선언만 하고 할당 (초기화) 을 하지 않았을 경우, 자바스크립트 엔진에 의해 기본적으로 (암묵적으로) `undefined`라는 값으로 초기화된다
- `undefined`는 원시 타입의 값 중 하나로, `null`과 비슷한 성질을 띄나 같지는 않다
- `undefined`가 없는 다른 언어는 대개 메모리 상에 남아있던 쓰레기 값으로 초기화되며, 이 쓰레기 값을 참조하다가 여러 문제가 발생할 수 있다

## 변수 선언의 실행 시점과 변수 호이스팅

```tsx
console.log(foo);

var foo = 1;
```

- 위의 예시에서 `foo` 변수는 선언 전에 사용되고 있다
  - `foo` 변수가 선언 전에 사용되었으므로 오류가 나야 할 것 같지만, 의외로 오류가 나지 않고 제대로 된 값이 출력된다
- 자바스크립트 엔진은 소스코드를 한 줄씩 실행하기 전에 소스 코드의 평가 과정을 거친다
  - 평가 과정에서 엔진은 모든 선언문 (변수, 함수, 클래스 등…) 을 찾아내 먼저 실행해 둔다
  - 그 뒤에 로직을 실행하므로, 코드상에서 나중에 선언된 변수라도 실행 순서는 더 빨라 오류가 나지 않는 것이다
- 이처럼 변수 선언문이 코드의 맨 앞에서 먼저 수행되는 현상을 호이스팅 (`hoisting`) 이라고 한다
  - `var`, `let`, `const`, `function`, `class` 키워드를 사용하는 모든 선언문은 호이스팅된다

## 값의 할당

```tsx
var foo; // 선언

foo = 1; // 할당
```

- 할당 연산자는 `=`을 사용한다

```tsx
var foo = 1;
```

- 위와 같이 선언과 할당을 동시에 할 수도 있다

```tsx
console.log(foo); // undefined

var foo; // 호이스팅 됨
foo = 1; // 호이스팅 안 됨
```

- 선언과 할당을 따로따로 하든, 한번에 하든 동작 자체는 똑같으나, 할당은 호이스팅되지 않는다
- 위의 예제에서 `foo`는 런타임 이전 평가 단계에서 선언이 이루어진다
  - 하지만 할당 (`foo = 1`) 은 런타임 시간에 수행되므로 `console.log(foo)` 보다 실행 타이밍이 늦다
  - 따라서 위 예제에서 출력값은 `undefined`이다

```tsx
console.log(foo); // undefined

var foo = 1;
```

- 선언과 할당을 동시에 해도, 자바스크립트 엔진은 선언과 할당을 따로따로 수행하기 때문에 할당 부분이 호이스팅되지 않는 것은 마찬가지이다
  - 따라서 위의 예제 출력값도 `undefined`이다

## 값의 재할당

```tsx
var foo = 1;

foo = 2;
```

- `var` 또는 `let` 변수는 값을 재할당할 수 있다
  - 사실 `var`과 `let`으로 선언한 값은 처음에 `undefined`로 초기화됨
  - 따라서 엄밀히 말하면 처음 할당하는 것도 `undefined`를 다른 값으로 재할당하는 것과 같음
  - `const`는 상수라 재할당이 안 됨
- 값의 재할당은 이전에 확보한 메모리 공간에서 값만 삭제하고 다시 덮어 씌우는 것이 아닌, 메모리 공간을 새롭게 확보하여 그곳에 값을 저장하는 방식으로 이루어진다
  - 재할당을 할 경우 이전에 확보했던 메모리 공간들은 변수와의 연결고리가 끊어지며, 언젠가 가비지 콜렉터에 의해 메모리에서 해제된다
  - 해제 타이밍은 알 수 없다

### 가비지 콜렉터

- 애플리케이션이 할당한 메모리 공간들을 주기적으로 검사하며, 더 이상 사용되지 않는 메모리 영역 (어떠한 식별자도 참조하지 않는 메모리 영역) 을 찾아내 해제한다
- 자바스크립트, 파이썬 등은 가비지 콜렉터를 내장하고 있는 **매니지드 언어**
  - 매니지드 언어는 메모리 관리를 언어 차원에서 자체적으로 지원하며, 사용자에게 메모리 직접 제어 권한이 없는 언어이다
  - 메모리의 해제는 가비지 콜렉터가 수행하며, 동작 타이밍 등은 사용자가 전혀 알 수 없다
- C, C++ 등은 가비지 콜렉터가 없어 자체적으로 메모리 누수 해결을 해 주어야 한다
  - 이렇게 사용자에게 메모리 관리 권한을 일임하는 언어는 **언매니지드 언어**라고 한다
  - `malloc`, `free` 등의 저수준 메모리 제어 기능을 제공한다
  - 개발자의 역량에 따라 메모리 확보 및 최적화 성능이 좌우되며, 다르게 말하면 개발자의 역량이 뒤떨어질 경우 치명적인 오류를 잔뜩 생산할 수 있다

## 식별자 네이밍 규칙

- 식별자는 문자, 숫자, 언더스코어 (`_`), 달러 (`$`) 기호만을 포함할 수 있다
- 식별자의 이름은 숫자로 시작할 수 없다
- 예약어는 식별자로 사용할 수 없다
  - `await`
  - `try` - `catch` - `finally`, `throw` (예외 제어)
  - `instanceof`
  - `function` - `class`, `var` - `let` - `const` (함수, 변수, 클래스 선언)
  - `extends` - `implements` - `super` (클래스 상속)
  - `public` - `private` - `protected` (클래스 접근 지정자)
  - `package`
  - `for` - `in` - `continue` - `break`, `do` - `while` (반복문)
  - `if` - `else`, `switch` - `case`(조건문)
  - `true` - `false` (boolean)
  - `debugger`
  - `export` - `import` - `default` (모듈 가져오기 및 내보내기)
  - `new` - `delete`
  - `enum`
  - `interface`
  - `typeof`
  - `null`
  - `return`
  - `yield`
  - `with`
  - `this`
  - `static`

```tsx
var foo, bar, dap;
```

- 한 줄에 여러 변수를 한꺼번에 선언하는 것도 가능하지만 가독성 면에서 추천하지 않는다

```tsx
var 안녕하세요, 変数, はい;
```

- 유니코드 문자라면 변수명으로 사용할 수는 있지만 알파벳 외에는 권장하지 않는다

```tsx
var test-name;
var 123name;
var this;
```

- 대시 (`-`) 는 변수명에 쓸 수 없다
- 변수명 맨 앞에는 숫자가 올 수 없다
- `this` 같은 예약어는 변수명으로 쓸 수 없다

```tsx
var foo;
var Foo;
var FOO;
```

- 변수명은 대소문자를 구분한다

```tsx
var foo; // 이 변수는 어쩔 때 사용합니다

var isLoading;
```

- 변수명은 주석이 필요없을 정도로 직관적으로 짓는 것이 좋다

### 네이밍 컨벤션

```tsx
var firstName; // camelCase
var first_name; // snake_case
var FirstName; // PascalCase

var numFirstName; // typeHungarianCase
```

- 네이밍 컨벤션을 정해서 사용하면 더 좋다
- 자바스크립트에서는 일반적인 변수에 카멜 케이스를 사용하고, 클래스명이나 생성자 함수, 컴포넌트 등에는 파스칼 케이스를 사용한다
- 그 외에는 팀별로 정하면 좋다
